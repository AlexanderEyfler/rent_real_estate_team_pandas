# Импорт библиотек
import pandas as pd
import numpy as np

from src.duplicat_checker import col_dup_remover1, col_dup_remover2

# Загрузка объекта и формирование датафрейма.
raw_Df= pd.read_csv('./Data/raw_data.csv')
df = raw_Df

# Дроп столбцов с явным отсутствием влияния на датафрейм.
df = df.drop(df.columns[0], axis=1)
df = df.drop(columns=[
    'ID  объявления', 
    'Тип', 
    'Телефоны', 
    'Описание', 
    'Площадь комнат, м2', 
    'Дополнительно', 
    'Серия дома', 
    'Ссылка на объявление', 
    'Окна', 
    'Название ЖК', 
    'Высота потолков, м', 
    'Мусоропровод'
], axis=1)

# Обработка столбца "Адрес"
# Удалить всё до следующего слова после "Москва" или "москва"
df['Адрес'] = df['Адрес'].str.replace(r'.*?\bМосква\b[\s,]*', '', case=False, regex=True).str.strip()

# Убираем явные дубликаты
df = col_dup_remover1(df)

# Обрабатываем столбцы
# Столбец "Количество комнат", переводим всё в int
# Шаг 1: Извлекаем числовые значения и сохраняем их как строки
df["Количество комнат"] = df["Количество комнат"].str.extract('(\d+)', expand=False)
# Шаг 2: Преобразуем строки в целые числа (int), игнорируя NaN
df["Количество комнат"] = pd.to_numeric(df["Количество комнат"], errors='coerce')
# Шаг 3: Преобразуем данные в тип Int64, чтобы поддерживать целые числа и NaN
df["Количество комнат"] = df["Количество комнат"].astype('Int64')
# Переименовываем столбец
df = df.rename(columns={'Количество комнат': 'Комнат'})

# Столбец "Метро", оставляем только станцию метро
df['Метро'] = df['Метро'].str.replace(r'\s*\(.*?\)', '', regex=True)

# Столбец "Площадь, м2", оставляем только площадь квартиры, предварительно переведя в float
# Шаг 1: Извлекаем все числа с плавающей запятой с помощью регулярного выражения
df['Площадь, м2'] = df['Площадь, м2'].str.findall(r'\d+\.?\d*')
# Шаг 2: Преобразуем строки чисел в float и оставляем их в списках
df['Площадь, м2'] = df['Площадь, м2'].apply(lambda x: [float(i) for i in x])
# Шаг 3: Оставляем только максимальное значение в каждом списке
df['Площадь, м2'] = df['Площадь, м2'].apply(lambda x: max(x) if len(x) > 0 else None)
# Шаг 4. Переименовываем столбец
df = df.rename(columns={'Площадь, м2': 'Площадь'})

# Столбец "Дом", переименуется на Этаж, добавятся также два столбца, "Этажность_дома" и "Материал_дома"
# Шаг 1: Извлекаем этаж и этажность дома
df[['Этаж', 'Этажность_дома']] = df['Дом'].str.extract(r'(?P<Этаж>\d+)/(?P<Этажность_дома>\d+)')
# Шаг 2: Преобразуем извлечённые значения в тип int, заменяя ошибки на NaN
df['Этаж'] = pd.to_numeric(df['Этаж'], errors='coerce').astype(int)
df['Этажность_дома'] = pd.to_numeric(df['Этажность_дома'], errors='coerce').astype(int)
# Шаг 3: Извлекаем материал дома и сразу удаляем запятые и пробелы, пустые строки делаем NaN
df['Материал_дома'] = df['Дом'].str.extract(r'\d+/\d+\s*,\s*(.*)').replace(r'^\s*$', np.nan, regex=True)
# Шаг 4: Определяем индекс "Дом", чтобы вставить новые колонки после неё
target_idx = df.columns.get_loc('Дом')
# Шаг 5: Удаляем столбец "Дом"
df = df.drop(columns=['Дом'])
# Шаг 6: Вставляем новые колонки на место удалённого "Дом"
df.insert(target_idx, 'Этаж', df.pop('Этаж'))
df.insert(target_idx + 1, 'Этажность_дома', df.pop('Этажность_дома'))
df.insert(target_idx + 2, 'Материал_дома', df.pop('Материал_дома'))

# Столбец "Балкон", создаётся дополнительный столбец "Лоджия"
# Шаг 1: Извлекаем количество балконов
df['Временный_балкон'] = df['Балкон'].str.extract(r'Балкон\s*\((\d+)\)').astype(float)
# Шаг 2: Извлекаем количество лодж
lodj_series = df['Балкон'].str.extract(r'Лоджия\s*\((\d+)\)').astype(float)
# Шаг 3: Определяем индекс столбца "Балкон", чтобы вставить новые столбцы после него
target_idx = df.columns.get_loc('Балкон')
# Вставляем столбец "Балкон_временный" и "Лоджия" после столбца "Балкон"
df.insert(target_idx + 1, 'Балкон_временный', df['Временный_балкон'])
df.insert(target_idx + 2, 'Лоджия', lodj_series)
# Шаг 4: Удаляем временный столбец "Временный_балкон"
df = df.drop(columns=['Временный_балкон'])
# Шаг 5: Логика заполнения: если исходное значение "Балкон" было NaN, оставляем NaN.
# В противном случае заменяем NaN на 0 в столбцах "Балкон_временный" и "Лоджия"
df.loc[df['Балкон'].notna(), 'Балкон_временный'] = df['Балкон_временный'].fillna(0)
df.loc[df['Балкон'].notna(), 'Лоджия'] = df['Лоджия'].fillna(0)
# Преобразуем в int, сохраняя NaN, если "Балкон" был NaN
df['Балкон_временный'] = df['Балкон_временный'].astype('Int64')
df['Лоджия'] = df['Лоджия'].astype('Int64')
# Шаг 6: Удаляем столбец "Балкон"
df = df.drop(columns=['Балкон'])
df = df.rename(columns={'Балкон_временный': 'Балкон'})

# Обработка столбца Санузел, изменяем его на санузел_совмещённый, и добавляем колонку санузел_раздельный.
# Шаг 1: Извлекаем количество совмещённых санузлов
df['Совмещённый_временный'] = df['Санузел'].str.extract(r'Совмещенный\s*\((\d+)\)').astype(float)
# Шаг 2: Извлекаем количество раздельных санузлов
razdelniy_series = df['Санузел'].str.extract(r'Раздельный\s*\((\d+)\)').astype(float)
# Шаг 3: Определяем индекс столбца "Санузел", чтобы вставить новые столбцы после него
target_idx = df.columns.get_loc('Санузел')
# Вставляем столбец "Санузел_совмещённый" и "Санузел_раздельный" после столбца "Санузел"
df.insert(target_idx + 1, 'Санузел_совмещённый', df['Совмещённый_временный'])
df.insert(target_idx + 2, 'Санузел_раздельный', razdelniy_series)
# Шаг 4: Удаляем временный столбец "Совмещённый_временный"
df = df.drop(columns=['Совмещённый_временный'])
# Шаг 5: Логика заполнения: если исходное значение "Санузел" было NaN, оставляем NaN.
# В противном случае заменяем NaN на 0 в столбцах "Санузел_совмещённый" и "Санузел_раздельный"
df.loc[df['Санузел'].notna(), 'Санузел_совмещённый'] = df['Санузел_совмещённый'].fillna(0)
df.loc[df['Санузел'].notna(), 'Санузел_раздельный'] = df['Санузел_раздельный'].fillna(0)
# Преобразуем в int, сохраняя NaN, если "Санузел" был NaN
df['Санузел_совмещённый'] = df['Санузел_совмещённый'].astype('Int64')
df['Санузел_раздельный'] = df['Санузел_раздельный'].astype('Int64')
# Шаг 6: Удаляем столбец "Санузел"
df = df.drop(columns=['Санузел'])

# Обработка столбца "Можно с детьми/животными", создаём два новых столбца. 
# Шаг 1: Создаем столбец "можно_с_детьми", используя .apply()
df['Можно_с_детьми'] = df['Можно с детьми/животными'].apply(lambda x: 1 if isinstance(x, str) and 'Можно с детьми' in x else (pd.NA if pd.isna(x) else 0))
# Шаг 2: Создаем столбец "можно_с_животными", используя .apply()
df['Можно_с_животными'] = df['Можно с детьми/животными'].apply(lambda x: 1 if isinstance(x, str) and 'Можно с животными' in x else (pd.NA if pd.isna(x) else 0))
# Шаг 3: Определяем индекс столбца 'Можно с детьми/животными'
target_idx = df.columns.get_loc('Можно с детьми/животными')
# Шаг 4: Вставляем новые столбцы сразу после столбца 'Можно с детьми/животными'
df.insert(target_idx + 1, 'Можно_с_детьми', df.pop('Можно_с_детьми'))
df.insert(target_idx + 2, 'Можно_с_животными', df.pop('Можно_с_животными'))
# Шаг 5: Удаляем столбец 'Можно с детьми/животными'
df = df.drop(columns=['Можно с детьми/животными'])

# Шаг 1: Извлекаем количество пассажирских лифтов
df['Временный_лифт_пасс'] = df['Лифт'].str.extract(r'Пассажирский\s*\((\d+)\)').astype(float)
# Шаг 2: Извлекаем количество грузовых лифтов
lift_gruz_series = df['Лифт'].str.extract(r'Грузовой\s*\((\d+)\)').astype(float)
# Шаг 3: Определяем индекс столбца "Лифт", чтобы вставить новые столбцы после него
target_idx = df.columns.get_loc('Лифт')
# Вставляем столбцы "Лифт_пасс" и "Лифт_груз" после столбца "Лифт"
df.insert(target_idx + 1, 'Лифт_пасс', df['Временный_лифт_пасс'])
df.insert(target_idx + 2, 'Лифт_груз', lift_gruz_series)
# Шаг 4: Удаляем временный столбец "Временный_лифт_пасс"
df = df.drop(columns=['Временный_лифт_пасс'])
# Шаг 5: Логика заполнения: если исходное значение "Лифт" было NaN, оставляем NaN.
# В противном случае заменяем NaN на 0 в столбцах "лифт_пасс" и "лифт_груз"
df.loc[df['Лифт'].notna(), 'Лифт_пасс'] = df['Лифт_пасс'].fillna(0)
df.loc[df['Лифт'].notna(), 'Лифт_груз'] = df['Лифт_груз'].fillna(0)
# Преобразуем в int, сохраняя NaN, если "Лифт" был NaN
df['Лифт_пасс'] = df['Лифт_пасс'].astype('Int64')
df['Лифт_груз'] = df['Лифт_груз'].astype('Int64')
# Шаг 6: Удаляем столбец "Лифт" и переименовываем временный столбец
df = df.drop(columns=['Лифт'])

# Шаг 1: Извлекаем значения цен вне зависимости от валюты
df['Цена_за_месяц'] = df['Цена'].str.extract(r'(\d+(?:\.\d+)?)(?:\s*руб|\s*\$|\s*€)')
df['Валюта'] = df['Цена'].str.extract(r'(руб|\$|€)')
# Шаг 2: Удаляем строки с валютой, отличной от рублей
df = df[df['Валюта'] == 'руб']
# Шаг 3: Преобразуем в тип float для обработки чисел с плавающей точкой
df['Цена_за_месяц'] = df['Цена_за_месяц'].str.replace('\s+', '', regex=True).astype(float)
# Шаг 4: Преобразуем столбец "Цена_за_месяц" в "Аренду"
df['Аренда'] = df['Цена_за_месяц'].astype(int)
# Шаг 5: Определяем индекс столбца "Цена"
target_idx = df.columns.get_loc('Цена')
# Шаг 6: Перемещаем "Аренда" после "Цена"
df.insert(target_idx + 1, 'Аренда', df.pop('Аренда'))
# Шаг 7: Удаляем ненужные столбцы
df = df.drop(columns=['Цена', 'Валюта', 'Цена_за_месяц'])
# Убираем явные дубликаты
df = col_dup_remover2(df)


known_metro = df[df['Метро'].notna()]

# Функция для заполнения пустых значений метро
def fill_metro(row):
    if pd.isna(row['Метро']):
        match = known_metro[known_metro['Адрес'] == row['Адрес']]
        if not match.empty:
            return match.iloc[0]['Метро']
    return row['Метро']

# Применение функции к каждой строке
df['Метро'] = df.apply(fill_metro, axis=1)


known_lifts = df[(df['Лифт_пасс'].notna()) | (df['Лифт_груз'].notna())]

# Функция для заполнения пустых значений "Лифт_пасс" и "Лифт_груз"
def fill_lifts(row):
    match = known_lifts[known_lifts['Адрес'] == row['Адрес']]
    
    # Заполняем "Лифт_пасс", если он пустой
    if pd.isna(row['Лифт_пасс']) and not match.empty:
        row['Лифт_пасс'] = match.iloc[0]['Лифт_пасс']
        
    # Заполняем "Лифт_груз", если он пустой
    if pd.isna(row['Лифт_груз']) and not match.empty:
        row['Лифт_груз'] = match.iloc[0]['Лифт_груз']

    if pd.isna(row['Парковка']) and not match.empty:
        row['Парковка'] = match.iloc[0]['Парковка']
        
    return row

# Применение функции к каждой строке
df = df.apply(fill_lifts, axis=1)


# Убираем выбросы в аренде
def remove_outliers_iqr(df, column):
    # Рассчитываем квартили
    Q1 = df[column].quantile(0.25)  # первый квартиль (25%)
    Q3 = df[column].quantile(0.75)  # третий квартиль (75%)
    IQR = Q3 - Q1  # межквартильный размах

    # Вычисляем нижнюю и верхнюю границы для выбросов
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Удаляем строки, где значение выходит за границы
    df_filtered = df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]
    
    return df_filtered

# Убираем выбросы в аренде
df_clean = remove_outliers_iqr(df, 'Аренда')
df = df.drop('Материал_дома', axis=1)

df_filtred = df



# Лифт_пасс и Лифт_груз заполняются по логике
# Если этажность_дома < 5, заполняем Лифт_пасс и Лифт_груз нулями
df_filtred.loc[df_filtred['Этажность_дома'] < 5, ['Лифт_пасс', 'Лифт_груз']] = df_filtred.loc[df_filtred['Этажность_дома'] < 5, ['Лифт_пасс', 'Лифт_груз']].fillna(0)
# Если 5 <= этажность_дома < 8, заполняем Лифт_пасс = 1, Лифт_груз = 0
df_filtred.loc[(df_filtred['Этажность_дома'] >= 5) & (df_filtred['Этажность_дома'] < 8), 'Лифт_пасс'] = df_filtred.loc[(df_filtred['Этажность_дома'] >= 5) & (df_filtred['Этажность_дома'] < 8), 'Лифт_пасс'].fillna(1)
df_filtred.loc[(df_filtred['Этажность_дома'] >= 5) & (df_filtred['Этажность_дома'] < 8), 'Лифт_груз'] = df_filtred.loc[(df_filtred['Этажность_дома'] >= 5) & (df_filtred['Этажность_дома'] < 8), 'Лифт_груз'].fillna(0)
# Если этажность_дома >= 8, заполняем Лифт_пасс = 1, Лифт_груз = 1
df_filtred.loc[df_filtred['Этажность_дома'] >= 8, ['Лифт_пасс', 'Лифт_груз']] = df_filtred.loc[df['Этажность_дома'] >= 8, ['Лифт_пасс', 'Лифт_груз']].fillna(1)
# Проверяем, как заполнены данные

